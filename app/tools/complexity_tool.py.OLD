"""Cyclomatic complexity analysis using Radon with Safety-First Execution."""
from pathlib import Path
from typing import Dict, Any, List
from app.core.base_tool import BaseTool
from app.core.subprocess_wrapper import SubprocessWrapper
from app.core.config import get_analysis_excludes_comma
from app.core.command_chunker import run_tool_in_chunks, filter_python_files, validate_file_list
import logging
import json
import sys

logger = logging.getLogger(__name__)


class ComplexityTool(BaseTool):
    """Analyze cyclomatic complexity using Radon."""
    
    @property
    def description(self) -> str:
        return "Measures cyclomatic complexity and maintainability index using Radon"
    
    def analyze(self, project_path: Path, file_list: List[str] = None) -> Dict[str, Any]:
        """
        Analyze code complexity using Radon with explicit file list.
        
        SAFETY-FIRST EXECUTION:
        1. Guard Clause: Empty file list check
        2. Guard Clause: Extension filter (only .py files)
        
        Args:
            project_path: Path to the project directory
            file_list: Optional list of absolute file paths to scan
            
        Returns:
            Dictionary with complexity metrics
        """
        if not self.validate_path(project_path):
            return {"error": "Invalid path"}
        
        # STEP 1: GUARD CLAUSE - Empty Check
        if file_list is not None and not file_list:
            logger.warning("Radon: Empty file list provided, skipping scan")
            return {
                "tool": "radon",
                "high_complexity_functions": [],
                "very_high_complexity_functions": [],
                "total_functions_analyzed": 0,
                "average_complexity": 0,
                "average_maintainability": 0,
                "maintainability_grade": "N/A",
                "files_analyzed": 0
            }
        
        # STEP 2: GUARD CLAUSE - Extension Filter
        if file_list:
            file_list = filter_python_files(file_list)
            if not validate_file_list(file_list, "Radon"):
                return {"error": "Invalid file list (contains excluded paths or empty)"}
            logger.info(f"âœ… Radon: Analyzing {len(file_list)} Python files (explicit list)")
        
        try:
            # Get cyclomatic complexity
            cc_results = self._get_cyclomatic_complexity(project_path, file_list)
            
            # Get maintainability index
            mi_results = self._get_maintainability_index(project_path, file_list)
            
            # Analyze results
            high_complexity = [
                item for item in cc_results
                if item['complexity'] > 10
            ]
            
            very_high_complexity = [
                item for item in cc_results
                if item['complexity'] > 15
            ]
            
            # Calculate averages
            avg_complexity = (
                sum(item['complexity'] for item in cc_results) / len(cc_results)
                if cc_results else 0
            )
            
            avg_maintainability = (
                sum(item['maintainability'] for item in mi_results) / len(mi_results)
                if mi_results else 0
            )
            
            return {
                "high_complexity_functions": high_complexity,
                "very_high_complexity_functions": very_high_complexity,
                "total_functions_analyzed": len(cc_results),
                "average_complexity": round(avg_complexity, 2),
                "average_maintainability": round(avg_maintainability, 2),
                "maintainability_grade": self._get_mi_grade(avg_maintainability),
                "files_analyzed": len(mi_results),
                "tool": "radon"
            }
        
        except Exception as e:
            logger.error(f"Complexity analysis failed: {e}")
            return {"error": str(e)}
    
    def _get_cyclomatic_complexity(self, project_path: Path, file_list: List[str] = None) -> List[Dict[str, Any]]:
        """Get cyclomatic complexity metrics."""
        results = []
        
        # Use explicit file list if provided - process individually for reliability
        if file_list:
            logger.info(f"Radon CC: Processing {len(file_list)} files individually")
            for file_path in file_list:
                cmd = [sys.executable, '-m', 'radon', 'cc', file_path, '-j', '-a']
                
                success, stdout, stderr = SubprocessWrapper.run_command(
                    cmd,
                    cwd=project_path,
                    timeout=30,  # Shorter timeout per file
                    check_venv=False
                )
                
                if not success:
                    if "not found" in stderr.lower():
                        logger.warning("Radon not installed")
                        return []
                    logger.debug(f"Radon cc skipped {file_path}: {stderr}")
                    continue
                
                try:
                    data = json.loads(stdout)
                    for fpath, functions in data.items():
                        if isinstance(functions, list):
                            for func in functions:
                                results.append({
                                    "file": fpath,
                                    "function": func.get('name', 'unknown'),
                                    "line": func.get('lineno', 0),
                                    "complexity": func.get('complexity', 0),
                                    "rank": func.get('rank', 'A')
                                })
                except json.JSONDecodeError:
                    logger.debug(f"Failed to parse radon output for {file_path}")
                    continue
            
            logger.info(f"Radon CC: Analyzed {len(results)} functions from {len(file_list)} files")
            return results
        
        # Fallback: Use centralized exclusion config for directory scan
        ignore_patterns = get_analysis_excludes_comma()
        cmd = [sys.executable, '-m', 'radon', 'cc', str(project_path), '-j', '-a', '-i', ignore_patterns]
        
        success, stdout, stderr = SubprocessWrapper.run_command(
            cmd,
            cwd=project_path,
            timeout=300,
            check_venv=False
        )
        
        if not success:
            if "not found" in stderr.lower():
                logger.warning("Radon not installed")
                return []
            logger.error(f"Radon cc failed: {stderr}")
            return []
        
        try:
            data = json.loads(stdout)
            
            for file_path, functions in data.items():
                if isinstance(functions, list):
                    for func in functions:
                        results.append({
                            "file": file_path,
                            "function": func.get('name', 'unknown'),
                            "line": func.get('lineno', 0),
                            "complexity": func.get('complexity', 0),
                            "rank": func.get('rank', 'A')
                        })
            
            return results
        
        except json.JSONDecodeError:
            logger.error("Failed to parse radon output")
            return []
    
    def _get_maintainability_index(self, project_path: Path, file_list: List[str] = None) -> List[Dict[str, Any]]:
        """Get maintainability index metrics."""
        results = []
        
        # Use explicit file list if provided - process individually for reliability
        if file_list:
            logger.info(f"Radon MI: Processing {len(file_list)} files individually")
            for file_path in file_list:
                cmd = [sys.executable, '-m', 'radon', 'mi', file_path, '-j']
                
                success, stdout, stderr = SubprocessWrapper.run_command(
                    cmd,
                    cwd=project_path,
                    timeout=30,  # Shorter timeout per file
                    check_venv=False
                )
                
                if not success:
                    logger.debug(f"Radon mi skipped {file_path}: {stderr}")
                    continue
                
                try:
                    data = json.loads(stdout)
                    for fpath, metrics in data.items():
                        if isinstance(metrics, dict):
                            results.append({
                                "file": fpath,
                                "maintainability": metrics.get('mi', 0),
                                "rank": metrics.get('rank', 'A')
                            })
                except json.JSONDecodeError:
                    logger.debug(f"Failed to parse radon mi output for {file_path}")
                    continue
            
            logger.info(f"Radon MI: Analyzed {len(results)} files")
            return results
        
        # Fallback: Use centralized exclusion config for directory scan
        ignore_patterns = get_analysis_excludes_comma()
        cmd = [sys.executable, '-m', 'radon', 'mi', str(project_path), '-j', '-i', ignore_patterns]
        
        success, stdout, stderr = SubprocessWrapper.run_command(
            cmd,
            cwd=project_path,
            timeout=300,
            check_venv=False
        )
        
        if not success:
            logger.error(f"Radon mi failed: {stderr}")
            return []
        
        try:
            data = json.loads(stdout)
            
            for file_path, metrics in data.items():
                if isinstance(metrics, dict):
                    results.append({
                        "file": file_path,
                        "maintainability": metrics.get('mi', 0),
                        "rank": metrics.get('rank', 'A')
                    })
            
            return results
        
        except json.JSONDecodeError:
            logger.error("Failed to parse radon mi output")
            return []
    
    def _get_mi_grade(self, mi_score: float) -> str:
        """Convert maintainability index to letter grade."""
        if mi_score >= 80:
            return 'A'
        elif mi_score >= 60:
            return 'B'
        elif mi_score >= 40:
            return 'C'
        elif mi_score >= 20:
            return 'D'
        else:
            return 'F'
